
<html>
<head>
<title>Mixed marker example with Three.js</title>
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
<style>
	html,body {
		margin: 0;
		padding: 0;
		width: 100%;
		text-align: center;
		overflow-x: hidden;
		background: #000;
	}
	.portrait canvas {
		transform-origin: 0 0;
		transform: rotate(-90deg) translateX(-100%);
	}
	.desktop canvas {
	 	transform: scale(-1, 1);
	}
	canvas {
		position: absolute;
		top: 50%;
		right: 0;
		transform: translateY(-50%);
		z-index: 99;
	}
	canvas:first-child {
		left: 0;
		right: auto;
	}
	#launch-btn {
		padding: 20px;
		position:absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%,-50%);
		font-size: 2em;
	}
</style>
</head>
<body>

<button type="button" id="launch-btn">Lancer l'app</button>
<script src='../../js/jquery/jquery-3.1.1.min.js'></script>
<script src="../../js/jsartoolkit/artoolkit.min.js"></script>
<script src="../../js/jsartoolkit/artoolkit.api.js"></script>
<script src="../../js/three.js/build/three.js"></script>
<script src="../../js/jsartoolkit/artoolkit.three.js"></script>


<script src='../../js/three.js/build/three.stereoscopic.js'></script>
<script src='../../js/three.js/build/three.videoTexture.js'></script>

<script id="vertexShader" type="x-shader/x-vertex">
	varying vec2 vUv; void main() { vUv = uv; vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 ); gl_Position = projectionMatrix * mvPosition; }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
	uniform sampler2D texture; uniform vec3 color; varying vec2 vUv; void main() { vec3 tColor = texture2D( texture, vUv ).rgb; float a = (length(tColor - color) - 0.5) * 7.0; gl_FragColor = vec4(tColor, a); }
</script>

<script>
var video;
var videoStatus = {
	currentMarkerId: 0,
	isMarkerDetected: false,
	newMarkerDetected: false,
	prevMarkerId: 0,
	bufferMarkersDetected: [],
	currentMarkersDetected: []
};
var videoSrcList = [
	"../../videos/intro-lg.mp4",
	"../../videos/papa-lg.mp4",
	"../../videos/maman-lg.mp4",
	"../../videos/a-lent-lg.mp4",
	"../../videos/a-rapide-lg.mp4",
	"../../videos/m-lent-lg.mp4",
	"../../videos/m-rapide-lg.mp4"

];

ChromaKeyMaterial = function (url, width, height, keyColor) {
	THREE.ShaderMaterial.call(this);
	video = document.createElement('video');
	video.loop = false;
	video.src = url;
	video.load();

	var videoImage = document.createElement('canvas');
	if (window["webkitURL"]) document.body.appendChild(videoImage);
	videoImage.width = width;
	videoImage.height = height;
	videoImage.style.display = 'none';
	var keyColorObject = new THREE.Color(keyColor);
	var videoImageContext = videoImage.getContext('2d');
	// background color if no video present
	videoImageContext.fillStyle = '#' + keyColorObject.getHexString();
	videoImageContext.fillRect(0, 0, videoImage.width, videoImage.height);
	var videoTexture = new THREE.Texture(videoImage);
	videoTexture.minFilter = THREE.LinearFilter;
	videoTexture.magFilter = THREE.LinearFilter;
	this.update = function () {
		if (video.readyState === video.HAVE_ENOUGH_DATA) {
			videoImageContext.drawImage(video, 0, 0);
			if (videoTexture) {
				videoTexture.needsUpdate = true;
			}
		}
	}
	this.setValues({
		uniforms: {
			texture: {
				type: "t",
				value: videoTexture
			},
			color: {
				type: "c",
				value: keyColorObject
			}
		},
		vertexShader: document.getElementById('vertexShader').textContent,
		fragmentShader: document.getElementById('fragmentShader').textContent,
		transparent: true
	});
}
ChromaKeyMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
if (Array.prototype.equals)
	console.warn("Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.");
// attach the .equals method to Array's prototype to call it on any array
Array.prototype.equals = function (array) {
		// if the other array is a falsy value, return
		if (!array)
			return false;

		// compare lengths - can save a lot of time
		if (this.length != array.length)
			return false;

		for (var i = 0, l = this.length; i < l; i++) {
			// Check if we have nested arrays
			if (this[i] instanceof Array && array[i] instanceof Array) {
				// recurse into the nested arrays
				if (!this[i].equals(array[i]))
					return false;
			} else if (this[i] != array[i]) {
				// Warning - two different object instances will never be equal: {x:20} != {x:20}
				return false;
			}
		}
		return true;
	}
	// Hide method from for-in loops
Object.defineProperty(Array.prototype, "equals", {
	enumerable: false
});

var launchBtn = document.getElementById('launch-btn');
var playButton = document.getElementById('play-btn');
var pauseButton = document.getElementById('pause-btn');
window.ARThreeOnLoad = function() {

	ARController.getUserMediaThreeScene({
		maxARVideoSize: 320,
		cameraParam: 'Data/camera_para.dat',
		facing: { exact: 'environment' },
		facingMode: { exact: 'environment'},
		onSuccess: function(arScene, arController, arCamera) {

			document.body.className = arController.orientation;

			arController.setPatternDetectionMode(artoolkit.AR_TEMPLATE_MATCHING_MONO_AND_MATRIX);

			var rendererL = new THREE.WebGLRenderer({antialias: true}),
					rendererR = new THREE.WebGLRenderer({antialias: true}),
					rendererWidth = window.innerWidth/2,
			ratio = arController.videoWidth / arController.videoHeight;
			rendererL.setSize(rendererWidth, rendererWidth/ratio);
			rendererR.setSize(rendererWidth, rendererWidth/ratio);


			document.body.insertBefore(rendererL.domElement, document.body.firstChild);
			document.body.insertBefore(rendererR.domElement, document.body.firstChild);
			var rotationV = 0;
			var rotationTarget = 0;

			var checkDuration = 500;

			var RAMarker = function(id) {
				this.videoSrc = videoSrcList[id];
				this.markerId = id;
			  this.ts = 0;
			  this.visible = false;
			};
			var marker1 = new RAMarker(0);
			var marker2 = new RAMarker(1);
			var marker3 = new RAMarker(2);
			var marker4 = new RAMarker(3);
			var marker5 = new RAMarker(4);
			var marker6 = new RAMarker(5);
			var marker7 = new RAMarker(6);
			var geometry = new THREE.PlaneGeometry(3.28, 2.46); // 4:3
			var movieMaterial = new ChromaKeyMaterial(videoSrcList[0], 1280, 720, 0xffffff)

			var cube = new THREE.Mesh(
				geometry,
				movieMaterial
			);
			cube.material.shading = THREE.FlatShading;
			cube.position.z = 0;
			cube.position.x = 2.2;
			cube.position.y = -1;
			var markerRoot = arController.createThreeBarcodeMarker(0);
			markerRoot.add(cube);
			arScene.scene.add(markerRoot);

			var readyToPlay = false;
			var eventNames = [
				'touchstart', 'touchend', 'touchmove', 'touchcancel',
				'click', 'mousedown', 'mouseup', 'mousemove',
				'keydown', 'keyup', 'keypress', 'scroll'
			];
			var firstFrame = 0,
	      videoEnded = 0,
	      firstMarker = 0;

	    //
	    //
	    // onMarkerFound(marker, jsArucoMarker, markerObject3D, markers) : fonction appelée à tous les frames
	    //
	    // utilisée uniquement pour mettre à jour le positionnement de la projection contenant la vidéo
	    //
	    //

	    function initVideo(video) {
	      videoStatus.currentVideoEl = video;
	      videoStatus.currentVideoEl.addEventListener('ended', function () {
	        onVideoEnded(videoStatus.currentVideoEl);
	      });

	    }

			function handleNewMarker (newMarker) {
				var ts = Date.now();
				if(newMarker === 0){
					if(marker1.visible === false){
						marker1.visible = true;
						updateVideo(marker1.videoSrc);
						console.log('changed marker1.visible to true');

					}
					marker1.ts = ts;



				}
				if(newMarker === 1){
					if(marker2.visible === false){
						marker2.visible = true;
						if(marker1.visible){
							updateVideo(marker2.videoSrc);
						}
						console.log('changed marker2.visible to true');
					}
					marker2.ts = ts;
				}
				if(newMarker === 2){
					if(marker3.visible === false){
						marker3.visible = true;
						if(marker1.visible){
							updateVideo(marker3.videoSrc);
						}
						console.log('changed marker2.visible to true');
					}
					marker3.ts = ts;
				}
				if(newMarker === 3){
					if(marker4.visible === false){
						marker4.visible = true;
						if(marker1.visible){
							updateVideo(marker4.videoSrc);
						}
						console.log('changed marker4.visible to true');
					}
					marker4.ts = ts;
				}
				if(newMarker === 4){
					if(marker5.visible === false){
						marker5.visible = true;
						if(marker1.visible){
							updateVideo(marker5.videoSrc);
						}
						console.log('changed marker5.visible to true');
					}
					marker5.ts = ts;
				}
				if(newMarker === 5){
					if(marker6.visible === false){
						marker6.visible = true;
						if(marker1.visible){
							updateVideo(marker6.videoSrc);
						}
						console.log('changed marker6.visible to true');
					}
					marker6.ts = ts;
				}
				if(newMarker === 6){
					if(marker7.visible === false){
						marker7.visible = true;
						if(marker1.visible){
							updateVideo(marker7.videoSrc);
						}
						console.log('changed marker7.visible to true');
					}
					marker7.ts = ts;
				}



			}
			function checkMarkerVisible () {
				var ts = Date.now();
				if(marker1.ts < ts - checkDuration && marker1.visible){
					marker1.visible = false;
					updateVideo();
					console.log('changed marker1.visible to false');
				}
				if(marker2.ts < ts - checkDuration && marker2.visible){
					marker2.visible = false;
					updateVideo(marker1.videoSrc);
					console.log('changed marker2.visible to false');
				}
				if(marker3.ts < ts - checkDuration && marker3.visible){
					marker3.visible = false;
					updateVideo(marker1.videoSrc);
					console.log('changed marker3.visible to false');
				}
				if(marker4.ts < ts - checkDuration && marker4.visible){
					marker4.visible = false;
					updateVideo(marker1.videoSrc);
					console.log('changed marker4.visible to false');
				}
				if(marker5.ts < ts - checkDuration && marker5.visible){
					marker5.visible = false;
					updateVideo(marker1.videoSrc);
					console.log('changed marker5.visible to false');
				}
				if(marker6.ts < ts - checkDuration && marker6.visible){
					marker6.visible = false;
					updateVideo(marker1.videoSrc);
					console.log('changed marker6.visible to false');
				}
				if(marker7.ts < ts - checkDuration && marker7.visible){
					marker7.visible = false;
					updateVideo(marker1.videoSrc);
					console.log('changed marker7.visible to false');
				}
			}


			function onEachFrame () {
				checkMarkerVisible();

			}

			function handleMotionEvent(event) {




			}


			arController.addEventListener('getMarker', function (e) {
					var marker = e.data.marker.idMatrix;
					if(e.data.type > -1 && marker >-1){
						handleNewMarker(marker);
					}
				});
			function updateVideo(videoSrc) {
				console.log('updating video');

	      // on ne met à jour que si la nouvelle source est différente de l'ancienne
				if(typeof videoSrc !== 'undefined'){
		      if (videoSrc !== videoStatus.currentVideoEl.src) {

						videoStatus.currentVideoEl.pause();
		        videoStatus.currentVideoEl.src = videoSrc;
						console.log(videoStatus.currentVideoEl.src);
						videoStatus.currentVideoEl.play();
		      }
				}
				else {
					videoStatus.currentVideoEl.pause();
					videoStatus.currentVideoEl.src = videoSrcList[0];
				}


	    }
			function onVideoEnded() {
	      videoStatus.currentVideoEl.pause();

	      setTimeout(function () {
	        videoStatus.currentVideoEl.currentTime = 0;
	        videoStatus.currentVideoEl.play();
	      }, 5000);
	    }


			function onMarkersUpdated() {
				if (videoStatus.currentMarkersDetected.length === 1) { // un seul marqueur trouvé
	      	if (videoStatus.currentMarkersDetected.indexOf(0) > -1) {
						videoStatus.currentVideoEl.play();
					}
				}
				else {
					videoStatus.currentVideoEl.pause();
				}


	      // if (videoStatus.newMarkerDetected === true) {
	      //   videoStatus.newMarkerDetected = false;
	      //   // Ici, on vient de trouver un nouveau marqueur
	      //   //
	      //   // on gère les différents cas
	      //   //
	      //   // 1. le marqueur de position (265) est le seul marqueur detecté, on lance la vidéo d'intro
	      //   //
	      //   // 2. le marqueur de position est detecté + un autre marqueur (pour l'instant : 1001)
	      //   //
	      //   // 3. le marqueur de position n'est pas trouvé, mais un autre marqueur est trouvé : on fait quoi ? pour l'instant : pause
	      //   //console.log(videoStatus.currentMarkersDetected, videoStatus.currentMarkersDetected.length);
	      //   if (videoStatus.currentMarkersDetected.length === 1) { // un seul marqueur trouvé
	      //     if (videoStatus.currentMarkersDetected.indexOf(0) > -1) { // c'est le marqueur de position
	      //       updateVideo(videoSrcList[0]);
	      //     } else { // ce n'est pas le marqueur de position, on fait quoi ?
				//
	      //     }
	      //   } else if (videoStatus.currentMarkersDetected.length === 2) {
	      //     var index = videoStatus.currentMarkersDetected.indexOf(0),
	      //       currentMarkersDetectedWithout0 = videoStatus.currentMarkersDetected.filter(function (i) {
	      //         return i !== 0
	      //       });
	      //     updateVideo(videoSrcList[currentMarkersDetectedWithout0]);
	      //   }
				//
	      // }
	    }
			function markersUpdated (){
				console.log(videoStatus.currentMarkersDetected);
			}

			function addToCurrentMarkers (newMarker) {
				if(videoStatus.currentMarkersDetected.indexOf(newMarker) === -1){
					videoStatus.currentMarkersDetected.push(newMarker);
					markersUpdated();
				}


			}
			function removeFromCurrentMarkers (marker) {
				if(videoStatus.currentMarkersDetected.indexOf(marker) > -1){
					var index = videoStatus.currentMarkersDetected.indexOf(marker);
					if (index > -1) {
						    videoStatus.currentMarkersDetected.splice(index, 1);
								markersUpdated();
						}
				}

			}
			function emptyCurrentMarkers () {
					videoStatus.currentMarkersDetected = [];
					markersUpdated();

			}
			function isInCurrentMarkers (marker) {
				var check = false;
				if(videoStatus.currentMarkersDetected.indexOf(marker) > -1){
					check = true;
				}
				return check;
			}
			function onMarkerFound (ev) {
				videoStatus.currentVideoEl.play();
				// var markerNum = arController.getMarkerNum(),
				// markerIdMatrix = ev.data.marker.idMatrix;
				// if (markerNum > 0) {
				// 	if ( markerRoot.visible) {
				// 		console.log('markerRoot visible');
				// 		videoStatus.currentVideoEl.play();
				// 		if( !isInCurrentMarkers(0) ){
				// 			addToCurrentMarkers(0);
				// 		}
				//
				//
				//
				// 		if(markerIdMatrix === 33){
				// 			if(!isInCurrentMarkers(33)){
				// 				updateVideo(videoSrcList[1]);
				// 				addToCurrentMarkers(33);
				// 			}
				// 		}
				// 		else {
				// 			removeFromCurrentMarkers(33);
				// 			updateVideo(videoSrcList[0]);
				// 		}
				//
				// 	}
				// 	else {
				// 		videoStatus.currentVideoEl.pause();
				// 		removeFromCurrentMarkers(0);
				// 	}
				// }
				// else {
				// 	videoStatus.currentVideoEl.pause();
				// }




					// var markers = arController.getMarkerNum();
					// console.log(artoolkit.getDetectedMarkers);
					// if (markers > 0) {
					// 	for ( var i = 0; i < markers; i++ ){
					// 		var marker = arController.getMarker(i);
					// 		var markerId = marker.idMatrix;
					// 		if(videoStatus.bufferMarkersDetected.indexOf(markerId) === -1 && markerId > -1){
					// 			videoStatus.bufferMarkersDetected.push(markerId);
					// 		}
					//
					// 		if (!videoStatus.bufferMarkersDetected.equals(videoStatus.currentMarkersDetected)) {
			    //         videoStatus.currentMarkersDetected = videoStatus.bufferMarkersDetected;
			    //         videoStatus.newMarkerDetected = true;
					//
			    //         // cette fonction va nous servir à controler le changement de vidéo
					//
					// 				console.log(videoStatus.currentMarkersDetected);
			    //         onMarkersUpdated();
			    //       }
					//
			    //       if (videoStatus.currentVideoEl) {
			    //         videoStatus.currentVideoEl.play();
			    //       }
					//
			    //     }
					// 	}
					// 	else {
					// 			videoStatus.currentMarkersDetected = videoStatus.bufferMarkersDetected = [];
					// 			onMarkersUpdated();
			    //       if (videoStatus.currentVideoEl) {
			    //         videoStatus.currentVideoEl.pause();
			    //       }
			    //     }


			}






			var tick = function() {
				arScene.process();
				cube.rotation.z += rotationV;
				rotationV *= 0.8;
				movieMaterial.update();
				arScene.renderOn(rendererL);
				arScene.renderOn(rendererR);
				requestAnimationFrame(tick);
				onEachFrame();
				if (firstFrame === 0) {
	        // On attache l'écouteur qu'une fois, en passant video comme argument de la fonction (ça nous permet d'y accéder en dehors de update() )
	        firstFrame++;
	        initVideo(video);

	      }



			};

			tick();

		}
	});

	delete window.ARThreeOnLoad;

};
launchBtn.addEventListener('click', function () {
	if (window.ARController && ARController.getUserMediaThreeScene) {
		ARThreeOnLoad();
	}
});

</script>

</body>
</html>
