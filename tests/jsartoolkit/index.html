
<html>
<head>
<title>Mixed marker example with Three.js</title>
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
<style>
	html,body {
		margin: 0;
		padding: 0;
		width: 100%;
		text-align: center;
		overflow-x: hidden;
		background: #000;
	}
	.portrait canvas {
		transform-origin: 0 0;
		transform: rotate(-90deg) translateX(-100%);
	}
	.desktop canvas {
	 	transform: scale(-1, 1);
	}
	canvas {
		position: absolute;
		top: 50%;
		right: 0;
		transform: translateY(-50%);
	}
	canvas:first-child {
		left: 0;
		right: auto;
	}
</style>
</head>
<body>


<script src="../../js/jsartoolkit/artoolkit.min.js"></script>
<script src="../../js/three.js/build/three.js"></script>
<script src="../../js/jsartoolkit/artoolkit.three.js"></script>

<script src='../../js/three.js/build/three.stereoscopic.js'></script>
<script src='../../js/three.js/build/three.videoTexture.js'></script>

<script id="vertexShader" type="x-shader/x-vertex">
	varying vec2 vUv; void main() { vUv = uv; vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 ); gl_Position = projectionMatrix * mvPosition; }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
	uniform sampler2D texture; uniform vec3 color; varying vec2 vUv; void main() { vec3 tColor = texture2D( texture, vUv ).rgb; float a = (length(tColor - color) - 0.5) * 7.0; gl_FragColor = vec4(tColor, a); }
</script>

<script>
var video;
var videoStatus = {
	currentMarkerId: 0,
	isMarkerDetected: false,
	newMarkerDetected: false,
	prevMarkerId: 0,
	bufferMarkersDetected: [],
	currentMarkersDetected: []
};
var videoSrcList = [
	"../../videos/intro-lg.mp4",
	"../../videos/papa-lg.mp4",
	"../../videos/maman-lg.mp4",
	"../../videos/a-lent-lg.mp4",
	"../../videos/a-rapide-lg.mp4",
	"../../videos/m-lent-lg.mp4",
	"../../videos/m-rapide-lg.mp4"

];

ChromaKeyMaterial = function (url, width, height, keyColor) {
	THREE.ShaderMaterial.call(this);
	video = document.createElement('video');
	video.loop = false;
	video.src = url;
	video.load();

	var videoImage = document.createElement('canvas');
	if (window["webkitURL"]) document.body.appendChild(videoImage);
	videoImage.width = width;
	videoImage.height = height;
	videoImage.style.display = 'none';
	var keyColorObject = new THREE.Color(keyColor);
	var videoImageContext = videoImage.getContext('2d');
	// background color if no video present
	videoImageContext.fillStyle = '#' + keyColorObject.getHexString();
	videoImageContext.fillRect(0, 0, videoImage.width, videoImage.height);
	var videoTexture = new THREE.Texture(videoImage);
	videoTexture.minFilter = THREE.LinearFilter;
	videoTexture.magFilter = THREE.LinearFilter;
	this.update = function () {
		if (video.readyState === video.HAVE_ENOUGH_DATA) {
			videoImageContext.drawImage(video, 0, 0);
			if (videoTexture) {
				videoTexture.needsUpdate = true;
			}
		}
	}
	this.setValues({
		uniforms: {
			texture: {
				type: "t",
				value: videoTexture
			},
			color: {
				type: "c",
				value: keyColorObject
			}
		},
		vertexShader: document.getElementById('vertexShader').textContent,
		fragmentShader: document.getElementById('fragmentShader').textContent,
		transparent: true
	});
}
ChromaKeyMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
if (Array.prototype.equals)
	console.warn("Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.");
// attach the .equals method to Array's prototype to call it on any array
Array.prototype.equals = function (array) {
		// if the other array is a falsy value, return
		if (!array)
			return false;

		// compare lengths - can save a lot of time
		if (this.length != array.length)
			return false;

		for (var i = 0, l = this.length; i < l; i++) {
			// Check if we have nested arrays
			if (this[i] instanceof Array && array[i] instanceof Array) {
				// recurse into the nested arrays
				if (!this[i].equals(array[i]))
					return false;
			} else if (this[i] != array[i]) {
				// Warning - two different object instances will never be equal: {x:20} != {x:20}
				return false;
			}
		}
		return true;
	}
	// Hide method from for-in loops
Object.defineProperty(Array.prototype, "equals", {
	enumerable: false
});
window.ARThreeOnLoad = function() {

	ARController.getUserMediaThreeScene({
		// maxARVideoSize: 640,
		// cameraParam: 'Data/camera_para_android.dat',
		facing: { exact: 'environment'},
		onSuccess: function(arScene, arController, arCamera) {

			document.body.className = arController.orientation;

			arController.setPatternDetectionMode(artoolkit.AR_TEMPLATE_MATCHING_MONO_AND_MATRIX);

			var rendererL = new THREE.WebGLRenderer({antialias: true}),
					rendererR = new THREE.WebGLRenderer({antialias: true}),
					rendererWidth = window.innerWidth/2,
			ratio = arController.videoWidth / arController.videoHeight;
			rendererL.setSize(rendererWidth, rendererWidth/ratio);
			rendererR.setSize(rendererWidth, rendererWidth/ratio);
			// if (arController.orientation === 'portrait') {
			// 	var w = (window.innerWidth / arController.videoHeight) * arController.videoWidth;
			// 	var h = window.innerWidth;
			// 	renderer.setSize(w, h);
			// 	renderer.domElement.style.paddingBottom = (w-h) + 'px';
			// } else {
			// 	if (/Android|mobile|iPad|iPhone/i.test(navigator.userAgent)) {
			// 		renderer.setSize(window.innerWidth, (window.innerWidth / arController.videoWidth) * arController.videoHeight);
			// 	} else {
			// 		renderer.setSize(arController.videoWidth, arController.videoHeight);
			// 		document.body.className += ' desktop';
			// 	}
			// }

			document.body.insertBefore(rendererL.domElement, document.body.firstChild);
			document.body.insertBefore(rendererR.domElement, document.body.firstChild);
			var rotationV = 0;
			var rotationTarget = 0;

			var checkDuration = 500;

			var RAMarker = function(id) {
				this.videoSrc = videoSrcList[id];
				this.markerId = id;
			  this.ts = 0;
			  this.visible = false;
			};
			var marker1 = new RAMarker(0);
			var marker2 = new RAMarker(1);
			var geometry = new THREE.PlaneBufferGeometry(2.72, 1.53); //16:9
			var movieMaterial = new ChromaKeyMaterial(videoSrcList[0], 1280, 720, 0xffffff)

			var cube = new THREE.Mesh(
				geometry,
				movieMaterial
			);
			cube.material.shading = THREE.FlatShading;
			cube.position.z = 0;
			cube.position.x = 2;
			cube.position.y = -0.5;
			var markerRoot = arController.createThreeBarcodeMarker(0);
			markerRoot.add(cube);
			arScene.scene.add(markerRoot);

			var firstFrame = 0,
	      videoEnded = 0,
	      firstMarker = 0;

	    //
	    //
	    // onMarkerFound(marker, jsArucoMarker, markerObject3D, markers) : fonction appelée à tous les frames
	    //
	    // utilisée uniquement pour mettre à jour le positionnement de la projection contenant la vidéo
	    //
	    //
	    function initVideo(video) {
	      videoStatus.currentVideoEl = video;
	      videoStatus.currentVideoEl.addEventListener('ended', function () {
	        onVideoEnded(videoStatus.currentVideoEl);
	      });
	    }

			function handleNewMarker (newMarker) {
				var ts = Date.now();
				if(newMarker === 0){
					if(marker1.visible === false){
						marker1.visible = true;
						updateVideo(marker1.videoSrc);
						console.log('changed marker1.visible to true');

					}
					marker1.ts = ts;



				}
				if(newMarker === 1){
					if(marker2.visible === false){
						marker2.visible = true;
						if(marker1.visible){
							updateVideo(marker2.videoSrc);
						}
						console.log('changed marker2.visible to true');
					}
					marker2.ts = ts;
				}




			}
			function checkMarkerVisible () {
				var ts = Date.now();
				if(marker1.ts < ts - checkDuration && marker1.visible){
					marker1.visible = false;
					updateVideo();
					console.log('changed marker1.visible to false');
				}
				if(marker2.ts < ts - checkDuration && marker2.visible){
					marker2.visible = false;
					updateVideo(marker1.videoSrc);
					console.log('changed marker2.visible to false');
				}
			}


			function onEachFrame () {
				checkMarkerVisible();
				// if(videoStatus.currentVideoEl){
				// 	if(marker1.visible && !marker2.visible){
				// 		updateVideo(marker1.videoSrc);
				//
				//
				// 	}
				// 	else if (marker1.visible && marker2.visible){
				// 		updateVideo(marker2.videoSrc);
				// 	}
				// 	else {
				// 		videoStatus.currentVideoEl.pause();
				// 	}
				// }

			}
			// arController.loadMultiMarker('Data/multi-barcode-4x3.dat', function(marker, markerNum) {
			//
			//
			//
			// 	console.log('multi is', marker);
			// 	console.log('submarker count', markerNum);
			//
			//
			//
			// 	arController.addEventListener('getMarker', function (e) {
			// 		var marker = e.data.marker.id;
			// 		console.log(marker);
			// 		if(marker > -1){
			// 			handleNewMarker(marker);
			// 		}
			// 	});
			// 	var markerRoot = arController.createThreeMultiMarker(marker);
			// 	arScene.scene.add(markerRoot);
			//
			//
			// 	var geometry = new THREE.PlaneBufferGeometry(2.72, 1.53); //16:9
			// 	var movieMaterial = new ChromaKeyMaterial(videoSrcList[0], 1280, 720, 0xffffff)
			//
			// 	var cube = new THREE.Mesh(
			// 		geometry,
			// 		movieMaterial
			// 	);
			// 	cube.material.shading = THREE.FlatShading;
			// 	cube.position.z = 0;
			// 	cube.position.x = 2;
			// 	cube.position.y = -0.5;
			// 	markerRoot.markers[0] = cube;
			// 	// Create an object that tracks the marker transform.
			// 	// var markerRoot = arController.createThreeBarcodeMarker(0);
			// 	//
			// 	// markerRoot.add(cube);
			// 	// arScene.scene.add(markerRoot);
			//
			//
			// 	var firstFrame = true;
			// 	var tick = function() {
			// 		requestAnimationFrame(tick);
			//
			// 		checkMarkerVisible();
			//
			// 		arScene.process();
			// 		arScene.renderOn(rendererL);
			// 		arScene.renderOn(rendererR);
			// 		if(firstFrame){
			// 			firstFrame = false;
			// 			initVideo(video);
			// 		}
			// 	};
			// 	tick();
			//
			// });

			arController.addEventListener('getMarker', function (e) {
					var marker = e.data.marker.idMatrix;
					if(e.data.type > -1 && marker >-1){
						handleNewMarker(marker);
					}
				});
			function updateVideo(videoSrc) {
				console.log('updating video');

	      // on ne met à jour que si la nouvelle source est différente de l'ancienne
				if(typeof videoSrc !== 'undefined'){
		      if (videoSrc !== videoStatus.currentVideoEl.src) {
		        videoStatus.currentVideoEl.pause();
						console.log(videoSrc);
		        videoStatus.currentVideoEl.src = videoSrc;
						console.log(videoStatus.currentVideoEl.src);
		        videoStatus.currentVideoEl.play();
		      }
				}
				else {
					videoStatus.currentVideoEl.pause();
				}

	    }
			function onVideoEnded() {
	      videoStatus.currentVideoEl.pause();

	      setTimeout(function () {
	        videoStatus.currentVideoEl.currentTime = 0;
	        videoStatus.currentVideoEl.play();
	      }, 5000);
	    }


			function onMarkersUpdated() {
				if (videoStatus.currentMarkersDetected.length === 1) { // un seul marqueur trouvé
	      	if (videoStatus.currentMarkersDetected.indexOf(0) > -1) {
						videoStatus.currentVideoEl.play();
					}
				}
				else {
					videoStatus.currentVideoEl.pause();
				}


	      // if (videoStatus.newMarkerDetected === true) {
	      //   videoStatus.newMarkerDetected = false;
	      //   // Ici, on vient de trouver un nouveau marqueur
	      //   //
	      //   // on gère les différents cas
	      //   //
	      //   // 1. le marqueur de position (265) est le seul marqueur detecté, on lance la vidéo d'intro
	      //   //
	      //   // 2. le marqueur de position est detecté + un autre marqueur (pour l'instant : 1001)
	      //   //
	      //   // 3. le marqueur de position n'est pas trouvé, mais un autre marqueur est trouvé : on fait quoi ? pour l'instant : pause
	      //   //console.log(videoStatus.currentMarkersDetected, videoStatus.currentMarkersDetected.length);
	      //   if (videoStatus.currentMarkersDetected.length === 1) { // un seul marqueur trouvé
	      //     if (videoStatus.currentMarkersDetected.indexOf(0) > -1) { // c'est le marqueur de position
	      //       updateVideo(videoSrcList[0]);
	      //     } else { // ce n'est pas le marqueur de position, on fait quoi ?
				//
	      //     }
	      //   } else if (videoStatus.currentMarkersDetected.length === 2) {
	      //     var index = videoStatus.currentMarkersDetected.indexOf(0),
	      //       currentMarkersDetectedWithout0 = videoStatus.currentMarkersDetected.filter(function (i) {
	      //         return i !== 0
	      //       });
	      //     updateVideo(videoSrcList[currentMarkersDetectedWithout0]);
	      //   }
				//
	      // }
	    }
			function markersUpdated (){
				console.log(videoStatus.currentMarkersDetected);
			}

			function addToCurrentMarkers (newMarker) {
				if(videoStatus.currentMarkersDetected.indexOf(newMarker) === -1){
					videoStatus.currentMarkersDetected.push(newMarker);
					markersUpdated();
				}


			}
			function removeFromCurrentMarkers (marker) {
				if(videoStatus.currentMarkersDetected.indexOf(marker) > -1){
					var index = videoStatus.currentMarkersDetected.indexOf(marker);
					if (index > -1) {
						    videoStatus.currentMarkersDetected.splice(index, 1);
								markersUpdated();
						}
				}

			}
			function emptyCurrentMarkers () {
					videoStatus.currentMarkersDetected = [];
					markersUpdated();

			}
			function isInCurrentMarkers (marker) {
				var check = false;
				if(videoStatus.currentMarkersDetected.indexOf(marker) > -1){
					check = true;
				}
				return check;
			}
			function onMarkerFound (ev) {
				videoStatus.currentVideoEl.play();
				// var markerNum = arController.getMarkerNum(),
				// markerIdMatrix = ev.data.marker.idMatrix;
				// if (markerNum > 0) {
				// 	if ( markerRoot.visible) {
				// 		console.log('markerRoot visible');
				// 		videoStatus.currentVideoEl.play();
				// 		if( !isInCurrentMarkers(0) ){
				// 			addToCurrentMarkers(0);
				// 		}
				//
				//
				//
				// 		if(markerIdMatrix === 33){
				// 			if(!isInCurrentMarkers(33)){
				// 				updateVideo(videoSrcList[1]);
				// 				addToCurrentMarkers(33);
				// 			}
				// 		}
				// 		else {
				// 			removeFromCurrentMarkers(33);
				// 			updateVideo(videoSrcList[0]);
				// 		}
				//
				// 	}
				// 	else {
				// 		videoStatus.currentVideoEl.pause();
				// 		removeFromCurrentMarkers(0);
				// 	}
				// }
				// else {
				// 	videoStatus.currentVideoEl.pause();
				// }




					// var markers = arController.getMarkerNum();
					// console.log(artoolkit.getDetectedMarkers);
					// if (markers > 0) {
					// 	for ( var i = 0; i < markers; i++ ){
					// 		var marker = arController.getMarker(i);
					// 		var markerId = marker.idMatrix;
					// 		if(videoStatus.bufferMarkersDetected.indexOf(markerId) === -1 && markerId > -1){
					// 			videoStatus.bufferMarkersDetected.push(markerId);
					// 		}
					//
					// 		if (!videoStatus.bufferMarkersDetected.equals(videoStatus.currentMarkersDetected)) {
			    //         videoStatus.currentMarkersDetected = videoStatus.bufferMarkersDetected;
			    //         videoStatus.newMarkerDetected = true;
					//
			    //         // cette fonction va nous servir à controler le changement de vidéo
					//
					// 				console.log(videoStatus.currentMarkersDetected);
			    //         onMarkersUpdated();
			    //       }
					//
			    //       if (videoStatus.currentVideoEl) {
			    //         videoStatus.currentVideoEl.play();
			    //       }
					//
			    //     }
					// 	}
					// 	else {
					// 			videoStatus.currentMarkersDetected = videoStatus.bufferMarkersDetected = [];
					// 			onMarkersUpdated();
			    //       if (videoStatus.currentVideoEl) {
			    //         videoStatus.currentVideoEl.pause();
			    //       }
			    //     }


			}






			var tick = function() {
				arScene.process();
				cube.rotation.z += rotationV;
				rotationV *= 0.8;
				movieMaterial.update();
				arScene.renderOn(rendererL);
				arScene.renderOn(rendererR);
				requestAnimationFrame(tick);
				onEachFrame();
				if (firstFrame === 0) {
	        // On attache l'écouteur qu'une fois, en passant video comme argument de la fonction (ça nous permet d'y accéder en dehors de update() )
	        firstFrame++;
	        initVideo(video);

	      }



			};

			tick();

		}
	});

	delete window.ARThreeOnLoad;

};

if (window.ARController && ARController.getUserMediaThreeScene) {
	ARThreeOnLoad();
}
</script>

</body>
</html>
